#!/usr/bin/env bash
# Geo Change Risk Platform - Local Development Setup Script (Linux/Mac)
# Usage: ./setup.sh [--skip-prerequisites] [--force]

set -e

# Script directory and repo root
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
REPO_ROOT="$(cd "$SCRIPT_DIR/../.." && pwd)"
INFRA_PATH="$REPO_ROOT/infra/local"
ENV_EXAMPLE_PATH="$INFRA_PATH/.env.example"
ENV_PATH="$INFRA_PATH/.env"
DOCKER_COMPOSE_PATH="$INFRA_PATH/docker-compose.yml"

# Flags
SKIP_PREREQUISITES=false
SKIP_ENV=false
FORCE=false

# Colors
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
CYAN='\033[0;36m'
NC='\033[0m' # No Color

info() { echo -e "${CYAN}[INFO]${NC} $1"; }
success() { echo -e "${GREEN}[OK]${NC} $1"; }
warn() { echo -e "${YELLOW}[WARN]${NC} $1"; }
error() { echo -e "${RED}[ERROR]${NC} $1"; }

show_help() {
    cat << EOF
Geo Change Risk Platform - Local Development Setup

Usage: ./setup.sh [options]

Options:
    --skip-prerequisites    Skip prerequisite checks
    --skip-env              Skip .env generation (use existing .env file)
    --force                 Force recreation of containers
    --help, -h              Show this help message

Prerequisites:
    - Docker (running)
    - .NET 8 SDK
    - Python 3.11+
    - Node.js 18+

This script will:
    1. Check prerequisites
    2. Generate .env with random credentials (if not exists)
    3. Generate app config files (appsettings.Development.json, pipeline .env)
    4. Start PostgreSQL/PostGIS and MinIO containers
    5. Wait for services to be healthy
    6. Create MinIO buckets

Using existing credentials:
    If you already have PostgreSQL/MinIO running or want custom credentials:
    1. Copy infra/local/.env.example to infra/local/.env
    2. Edit .env with your credentials and ports
    3. Run: ./setup.sh --skip-env

EOF
}

command_exists() {
    command -v "$1" >/dev/null 2>&1
}

generate_password() {
    # Generate a random 24-character password using /dev/urandom
    # Falls back to $RANDOM if urandom is not available
    if [ -r /dev/urandom ]; then
        LC_ALL=C tr -dc 'A-Za-z0-9' < /dev/urandom | head -c 24
    else
        # Fallback for systems without /dev/urandom
        echo "$(date +%s%N)$RANDOM" | sha256sum | head -c 24
    fi
}

check_prerequisites() {
    info "Checking prerequisites..."
    local failed=false

    # Docker
    if command_exists docker; then
        local docker_version
        docker_version=$(docker --version)
        success "Docker: $docker_version"

        # Check if Docker is running
        if docker info >/dev/null 2>&1; then
            success "Docker daemon is running"
        else
            error "Docker daemon is not running. Please start Docker."
            failed=true
        fi
    else
        error "Docker is not installed. Please install Docker."
        failed=true
    fi

    # .NET SDK
    if command_exists dotnet; then
        local dotnet_version
        dotnet_version=$(dotnet --version)
        success ".NET SDK: $dotnet_version"
    else
        error ".NET SDK is not installed. Please install .NET 8 SDK."
        failed=true
    fi

    # Python
    if command_exists python3; then
        local python_version
        python_version=$(python3 --version 2>&1)
        success "Python: $python_version"
    elif command_exists python; then
        local python_version
        python_version=$(python --version 2>&1)
        success "Python: $python_version"
    else
        warn "Python is not installed. Required for AOI data scripts."
    fi

    # Node.js
    if command_exists node; then
        local node_version
        node_version=$(node --version)
        success "Node.js: $node_version"
    else
        warn "Node.js is not installed. Required for Web UI."
    fi

    if [ "$failed" = true ]; then
        error "Prerequisites check failed. Please install missing dependencies."
        exit 1
    fi
    success "All prerequisites satisfied"
}

initialize_env_file() {
    info "Checking environment file..."

    if [ ! -f "$ENV_PATH" ]; then
        info "Generating .env with random credentials..."

        # Generate random passwords
        GENERATED_PG_PASSWORD=$(generate_password)
        GENERATED_MINIO_PASSWORD=$(generate_password)

        # Create .env file with generated passwords
        cat > "$ENV_PATH" << EOF
# Geo Change Risk Platform - Local Environment Configuration
# Generated by setup script on $(date -Iseconds)
#
# DO NOT commit this file to version control

# =============================================================================
# PostgreSQL / PostGIS
# =============================================================================
POSTGRES_USER=gis
POSTGRES_PASSWORD=${GENERATED_PG_PASSWORD}
POSTGRES_DB=georisk
POSTGRES_PORT=5432

# =============================================================================
# MinIO (S3-compatible Object Storage)
# =============================================================================
MINIO_ROOT_USER=minioadmin
MINIO_ROOT_PASSWORD=${GENERATED_MINIO_PASSWORD}
MINIO_API_PORT=9000
MINIO_CONSOLE_PORT=9001

# =============================================================================
# API Configuration
# =============================================================================
API_PORT=5074

# =============================================================================
# Web UI Configuration
# =============================================================================
WEB_UI_PORT=5173
EOF

        success "Generated $ENV_PATH with random credentials"
    else
        success ".env file already exists (keeping existing credentials)"
    fi
}

generate_app_configs() {
    info "Generating application config files..."

    # Read credentials from .env
    local pg_user pg_pass pg_db pg_port minio_user minio_pass minio_port
    pg_user=$(grep "^POSTGRES_USER=" "$ENV_PATH" | cut -d'=' -f2)
    pg_pass=$(grep "^POSTGRES_PASSWORD=" "$ENV_PATH" | cut -d'=' -f2)
    pg_db=$(grep "^POSTGRES_DB=" "$ENV_PATH" | cut -d'=' -f2)
    pg_port=$(grep "^POSTGRES_PORT=" "$ENV_PATH" | cut -d'=' -f2)
    minio_user=$(grep "^MINIO_ROOT_USER=" "$ENV_PATH" | cut -d'=' -f2)
    minio_pass=$(grep "^MINIO_ROOT_PASSWORD=" "$ENV_PATH" | cut -d'=' -f2)
    minio_port=$(grep "^MINIO_API_PORT=" "$ENV_PATH" | cut -d'=' -f2)

    # Generate appsettings.Development.json for .NET API
    local appsettings_path="$REPO_ROOT/src/api/GeoChangeRisk.Api/appsettings.Development.json"
    if [ ! -f "$appsettings_path" ]; then
        cat > "$appsettings_path" << EOF
{
  "Logging": {
    "LogLevel": {
      "Default": "Debug",
      "Microsoft.AspNetCore": "Information",
      "Microsoft.EntityFrameworkCore.Database.Command": "Information"
    }
  },
  "ConnectionStrings": {
    "DefaultConnection": "Host=localhost;Port=${pg_port:-5432};Database=${pg_db:-georisk};Username=${pg_user:-gis};Password=${pg_pass};SSL Mode=Disable"
  },
  "MinIO": {
    "AccessKey": "${minio_user:-minioadmin}",
    "SecretKey": "${minio_pass}"
  },
  "Python": {
    "Executable": "${REPO_ROOT}/src/pipeline/.venv/bin/python",
    "PipelineDir": "${REPO_ROOT}/src/pipeline"
  }
}
EOF
        success "Generated $appsettings_path"
    else
        success "appsettings.Development.json already exists (keeping existing)"
    fi

    # Generate .env for Python pipeline
    local pipeline_env_path="$REPO_ROOT/src/pipeline/.env"
    if [ ! -f "$pipeline_env_path" ]; then
        cat > "$pipeline_env_path" << EOF
# Generated by setup script - DO NOT commit to version control
MINIO_ENDPOINT=localhost:${minio_port:-9000}
MINIO_ACCESS_KEY=${minio_user:-minioadmin}
MINIO_SECRET_KEY=${minio_pass}
EOF
        success "Generated $pipeline_env_path"
    else
        success "Pipeline .env already exists (keeping existing)"
    fi
}

start_infrastructure() {
    info "Starting infrastructure services..."

    cd "$INFRA_PATH"

    if [ "$FORCE" = true ]; then
        info "Force flag set - recreating containers..."
        docker-compose down -v
    fi

    docker-compose up -d

    if [ $? -ne 0 ]; then
        error "Failed to start docker-compose services"
        exit 1
    fi
    success "Docker containers started"

    cd "$REPO_ROOT"
}

wait_for_services() {
    local timeout_seconds=${1:-60}
    local retry_interval=${2:-5}

    info "Waiting for services to be healthy (timeout: ${timeout_seconds}s)..."

    local elapsed=0
    local postgres_ready=false
    local minio_ready=false

    while [ $elapsed -lt $timeout_seconds ]; do
        # Check PostgreSQL
        if [ "$postgres_ready" = false ]; then
            local pg_health
            pg_health=$(docker inspect --format='{{.State.Health.Status}}' georisk-postgres 2>/dev/null || echo "unknown")
            if [ "$pg_health" = "healthy" ]; then
                success "PostgreSQL is healthy"
                postgres_ready=true
            fi
        fi

        # Check MinIO
        if [ "$minio_ready" = false ]; then
            local minio_health
            minio_health=$(docker inspect --format='{{.State.Health.Status}}' georisk-minio 2>/dev/null || echo "unknown")
            if [ "$minio_health" = "healthy" ]; then
                success "MinIO is healthy"
                minio_ready=true
            fi
        fi

        if [ "$postgres_ready" = true ] && [ "$minio_ready" = true ]; then
            success "All services are healthy"
            return 0
        fi

        sleep $retry_interval
        elapsed=$((elapsed + retry_interval))
        echo -n "."
    done

    echo ""
    [ "$postgres_ready" = false ] && error "PostgreSQL did not become healthy in time"
    [ "$minio_ready" = false ] && error "MinIO did not become healthy in time"
    exit 1
}

initialize_minio_buckets() {
    info "Creating MinIO buckets..."

    # Load env vars
    if [ -f "$ENV_PATH" ]; then
        # shellcheck disable=SC1090
        set -a
        source "$ENV_PATH"
        set +a
    fi

    local minio_user="${MINIO_ROOT_USER:-minioadmin}"
    local minio_pass="${MINIO_ROOT_PASSWORD}"
    if [ -z "$minio_pass" ]; then
        error "MINIO_ROOT_PASSWORD not found in .env file"
        return 1
    fi

    local buckets=("geo-rasters" "geo-artifacts" "ml-models")

    # Configure mc alias inside container
    docker exec georisk-minio mc alias set local http://localhost:9000 "$minio_user" "$minio_pass" 2>/dev/null || true

    for bucket in "${buckets[@]}"; do
        if ! docker exec georisk-minio mc ls "local/$bucket" >/dev/null 2>&1; then
            if docker exec georisk-minio mc mb "local/$bucket" 2>/dev/null; then
                success "Created bucket: $bucket"
            else
                warn "Could not create bucket: $bucket"
            fi
        else
            success "Bucket already exists: $bucket"
        fi
    done
}

show_summary() {
    # Load credentials from .env for display
    local pg_user pg_pass minio_user minio_pass
    if [ -f "$ENV_PATH" ]; then
        pg_user=$(grep "^POSTGRES_USER=" "$ENV_PATH" | cut -d'=' -f2)
        pg_pass=$(grep "^POSTGRES_PASSWORD=" "$ENV_PATH" | cut -d'=' -f2)
        minio_user=$(grep "^MINIO_ROOT_USER=" "$ENV_PATH" | cut -d'=' -f2)
        minio_pass=$(grep "^MINIO_ROOT_PASSWORD=" "$ENV_PATH" | cut -d'=' -f2)
    fi

    echo ""
    echo -e "${GREEN}========================================${NC}"
    echo -e "${GREEN} Local Development Setup Complete!${NC}"
    echo -e "${GREEN}========================================${NC}"
    echo ""
    echo "Services:"
    echo "  PostgreSQL/PostGIS: localhost:5432"
    echo "  MinIO API:          localhost:9000"
    echo "  MinIO Console:      http://localhost:9001"
    echo ""
    echo "Credentials (from $ENV_PATH):"
    echo "  PostgreSQL: ${pg_user:-gis} / ${pg_pass:-<not set>}"
    echo "  MinIO:      ${minio_user:-minioadmin} / ${minio_pass:-<not set>}"
    echo ""
    echo "Next Steps:"
    echo "  1. Run database migrations (after creating API project)"
    echo "  2. Initialize an Area of Interest"
    echo ""
    echo "Useful Commands:"
    echo "  docker-compose -f infra/local/docker-compose.yml logs -f"
    echo "  docker-compose -f infra/local/docker-compose.yml down"
    echo ""
}

# Parse arguments
while [[ $# -gt 0 ]]; do
    case $1 in
        --skip-prerequisites)
            SKIP_PREREQUISITES=true
            shift
            ;;
        --skip-env)
            SKIP_ENV=true
            shift
            ;;
        --force)
            FORCE=true
            shift
            ;;
        --help|-h)
            show_help
            exit 0
            ;;
        *)
            error "Unknown option: $1"
            show_help
            exit 1
            ;;
    esac
done

# Main execution
echo ""
echo -e "${CYAN}Geo Change Risk Platform - Local Setup${NC}"
echo -e "${CYAN}=======================================${NC}"
echo ""

if [ "$SKIP_PREREQUISITES" = false ]; then
    check_prerequisites
fi

if [ "$SKIP_ENV" = true ]; then
    if [ ! -f "$ENV_PATH" ]; then
        error "No .env file found at $ENV_PATH"
        error "Create it from .env.example or remove --skip-env flag"
        exit 1
    fi
    success "Using existing .env file"
else
    initialize_env_file
fi

generate_app_configs
start_infrastructure
wait_for_services 60 5
initialize_minio_buckets
show_summary
